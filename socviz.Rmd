---
title: "Data Visualization Notes"
author: "Jon Quigley"
date: "2020-02-26"
output: html_document
---
   
## Data Visualization Notes

This is a starter RMarkdown template to accompany *Data Visualization* (Princeton University Press, 2019). You can use it to take notes, write your code, and produce a good-looking, reproducible document that records the work you have done. At the very top of the file is a section of *metadata*, or information about what the file is and what it does. The metadata is delimited by three dashes at the start and another three at the end. You should change the title, author, and date to the values that suit you. Keep the `output` line as it is for now, however. Each line in the metadata has a structure. First the *key* ("title", "author", etc), then a colon, and then the *value* associated with the key.  

## This is an RMarkdown File 

Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

**R Shortcuts:**

- *Alt + -* for assignment operator <-  
  
  
  
**R Mardown tips 'n Tricks:**

- Denote a header with #
- Denote subheader with ##
- Denote italics with *this*
- Denote **bold** with this
- Denote `verbatim` like this
- 1. for a list
- Footnotes like this.[^1]
- `[^1]: the actual footnote like this`


- *Ctrl + Alt + I* to insert code chunks
- *Alt + Enter* to run current line of code
- *Alt + Shift + K* for help window

(more here: http://rmarkdown.rstudio.com,  
and here: https://ismayc.github.io/thesisdown_book/1-rmd-basics.html)

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. A *code chunk* is a specially delimited section of the file. You can add one by moving the cursor to a blank line choosing Code > Insert Chunk from the RStudio menu. When you do, an empty chunk will appear:

```{r}


```

Code chunks are delimited by three backticks (found to the left of the 1 key on US and UK keyboards) at the start and end. The opening backticks also have a pair of braces and the letter `r`, to indicate what language the chunk is written in. You write your code inside the code chunks. Write your notes and other material around them, as here. 

## Before you Begin

To install the tidyverse, make sure you have an Internet connection. Then *manually* run the code in the chunk below. If you knit the document if will be skipped. We do this because you only need to install these packages once, not every time you run this file. Either knit the chunk using the little green "play" arrow to the right of the chunk area, or copy and paste the text into the console window.

```{r install, eval = FALSE}

## This code will not be evaluated automatically.
## (Notice the eval = FALSE declaration in the options section of the
## code chunk)

my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "svglite", viridis", "viridisLite", "devtools")

install.packages(my_packages, repos = "http://cran.rstudio.com")

```

## Set Up Your Project and Load Libraries

To begin we must load some libraries we will be using. If we do not load them, R will not be able to find the functions contained in these libraries. The tidyverse includes ggplot and other tools. We also load the socviz and gapminder libraries.

```{r setup, include=FALSE}

## By defult, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(echo = TRUE) 

## Set the default size of figures
knitr::opts_chunk$set(fig.width=8, fig.height=5)  

## Load the libraries we will be using
library(gapminder)
library(here)
library(socviz)
library(tidyverse)
library(svglite)

```

Notice that here, the braces at the start of the code chunk have some additional options set in them. There is the language, `r`, as before. This is required. Then there is the word `setup`, which is a label for your code chunk. Labels are useful to briefly say what the chunk does. Label names must be unique (no two chunks in the same document can have the same label) and cannot contain spaces. Then, after the comma, an option is set: `include=FALSE`. This tells R to run this code but not to include the output in the final document. 


When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r look}
gapminder
```
  
The remainder of this document contains the chapter headings for the book, and an empty code chunk in each section to get you started. Try knitting this document now by clicking the "Knit" button in the RStudio toolbar, or choosing File > Knit Document from the RStudio menu.

## Chapter 1:  Look at Data
```{r}

```
  
## Chapter 2: Get Started
  
Load the *tidyverse* library:  
```{r}
library(tidyverse)
```
  
Load the *socviz* library:
```{r}
library(socviz)
```
  
### Chapter 2.3: ****************
Almost verything is an **object**.
  
The **command** `c()` is a **function** - "c" is short for concatenate:
```{r}
c(1,2,3,1,3,5,25)
```
  
Assign these results to an **object**:
```{r}
my_numbers<-c(1,2,3,1,3,5,25)

your_numbers<-c(5,31,71,1,3,21,6)
```
  
The object `my_numbers` is a numeric **vector**:
```{r}
my_numbers
```
  
`mean()` is a function which acts on a vector of numbers

```{r}
mean(x = my_numbers)

mean(x = your_numbers)
```
  
We don't need to specify the name "x" for the function to work:
```{r}
mean(my_numbers)


summary(my_numbers)
```
  
We can **assign** the result of a function to an object
```{r}
my_summary <- summary(my_numbers)

my_summary
```
  
Functions come in **packages**:
```{r}
table(my_numbers) #a table of counts

sd(my_numbers) #standard deviation
```
  
Vectorized operations:
```{r}
my_numbers * 5 #multiplies each number in the vector by 5

my_numbers + 1 #adds one to each number in the vector
 
my_numbers + my_numbers #adds the vectors
```
  
Ask for the class of an object:
```{r}
class(my_numbers)

class(my_summary)

class(summary)
```
  
We may change the class after certain operations:
```{r}
my_new_vector <- c(my_numbers, "apple")

my_new_vector
```
  
Adding the word apple to our list of numbers changed the class:  
```{r}
class(my_new_vector)
```

**Data frames** are the most common kind of data object.  Date frames are rectangular table with rows (observations) and columns (variables).  
Columns in data frames can be different types:
  
```{r}
titanic
?titanic
class(titanic)
summary(titanic)
```
  
Access a named column with a `$` operator:
```{r}
titanic$percent
```
  
Access first two observations (rows), and all variables (columns):  
```{r}
titanic[1:2,]
```
  
Access observations for females only:
```{r}
subset(titanic, sex == 'female')
```
  
Access observations for females only, where percent < 10:
```{r}
subset(titanic, sex == 'female' & percent < 10)
```

Access observations for females only, where percent < 10, but keep only sex and fate variables:
```{r}
subset(titanic, sex == 'female' & percent < 10, select=c(fate, sex))
```

See Appendix 1 for more info on selecting elements.  
  
A **tibble** is an enhanced kind of data frame.  
  
Convert a data frame to a tibble:
```{r}
titanic_tb <- as_tibble(titanic)

titanic_tb
```

The `str()` function lets us see what is inside an object:
```{r}
str(titanic_tb)
```
  
  
  
### Chapter 2.4***************
In ggplot, we'll build plots one element at a tim by adding expressions.  

Be careful to place "+" at the end of the lines and not the beginning:
```{r}
ggplot(data = mpg, aes(x = displ, y = hwy)) + 
     geom_point() 
```

### Chapter 2.5 Get Data into R***************
Use `read_csv()` from the readr package (it's in the tidyverse).  
  
We can read in a local file or a remote file.  For example:

```{r}
url <- "https://cdn.rawgit.com/kjhealy/viz-organdata/master/organdonation.csv"

organs <- read_csv(url)
```
  
When preparing data for use in R, it's best if in **Tidy** format.

https://r4ds.had.co.nz/tidy-data.html

- each variable is a column
- each observation is a row
- each type of observational unit forms a table  

Untidy census table:  
```{r}
edu
```

Use `gather()` to transform the schooling variables into a **key-value arrangement**.  
Key is the underlying variable, value is the value of the observation:
```{r}
edu_tidy <- gather(data = edu,
                   key = school,
                   value = freq, 
                   elem4 : coll4)

head(edu_tidy, 10)
tail(edu_tidy, 10)
```
  
### Chapter 2.6 First Plot***************
```{r}
library(gapminder)

gapminder

p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point()

```


## Chapter 3: Make a Plot  
  
### 3.2 Tidy Data  
Tidyverse tools like to see **long-format** data.  
  
### 3.3 Mappings Link Data to Things We See
  
We can use a recipe for creating each plot in R:  
  
1. Start with **tidy** data - usually a data frame or a tibble  
2. tell the core *ggplot* function what our data is, and what the *mappings* are (and assign to "p")  
3. Choose a plot type, or *geom* and add it to "p"  
4. Add more features, such as adjusted elements, adjusted scales, title and labels, etc...  
    
Remind ourselves what `gapminder` data looks like:
```{r}
str(gapminder)
head(gapminder, 10)
tail(gapminder, 10)
```
  
Now, let's follow the recipe:  
2.  tell the core *ggplot* function what our *data* is (and assign it "p"), and what the *mappings* are:  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
```
  
The `mapping = aes()` argument links variables to to things we'll see on the plot.  
These mappings can include items such as color, shape, size, and line characteristics.  

3. Choose a plot type, or *geom* and add it to "p"   

Here, we use the data in a scatterplot:
```{r}
p +
     geom_point()
```
  
### 3.4 Build Plots Layer by Layer

Let's try a different *geom_* function:  
```{r}
p +
     geom_smooth()
```
  
Here, we can see the geom_ function has some special qualities by default.  
It no longer maps the individual points; instead it's calculated a smooth line with a shaded area equal to the standard error.  By default, the smoothed line is determined via *gam* method - general additive model.  
  
If we want to add the points back in, we can add 'geom_point()' back in:  
```{r}
p +
     geom_smooth() +
     geom_point()
```
  
We can also change from the default gam method to a linear model fit:  
```{r}
p +
     geom_smooth(method = "lm") +
     geom_point()
```
  
We can see wo bunched GDP is on the left hand side of the x-axis.  By applying a log scale to the x-axis, we can improve the clarity:  
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_x_log10()
```
  
The log xform is applied prior to the scaling function.  
  
There are a number of scale xform we can apply; each has its own name, and reference the axis it applies to:
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_y_log10()
```
    
Next, we'd want to add axis labels, a title, and clean up the tick mark formatting.  

Labels on tick marks are controlled through the *scale_* functions.  
  
The `scales` package contains some useful formats. Rather than load the package with `library(scales)', we can grab the function directly from the library using the syntax `thepackage::thefunction'.  
  
To do this for the x-axis:  
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_x_log10(labels = scales::dollar)
```
  
In general regarding scale transforms:  
1. we can directly xform by adding *scale_y_* or *scale_x_* to the plot.  
2. then, we can give this *scale_* function a *labels* argument.  
    
      
### 3.5 Mapping Aesthetics vs. Setting Them  
  
An *aesthetic mapping* specifies which color, shape, size, etc... a varibale will be represented as.  We can map a variable like this:  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent))

p + geom_point() +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar)
```
  
If we wanted to turn all points in the plot purple, we do not assign the color purple in the aesthetic; we set it in the geom_():  

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(color = "purple") +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar)
```

Now, we're no longer assigning continents to colors, we're simply coloring all points purple - so we also get only one regression line.  
  
`geom_()` functions can take other inputs which impact appearance without being mapped to aesthetic.  
  
```{r}
p + geom_point(alpha = 0.3) +
     geom_smooth(color = "orange", se=FALSE, size = 8, method = "lm") +
     scale_x_log10(labels = scales::dollar)
```
  
* adding `alpha = 0.3` to `geom_point` sets the tranparency of the dots to 0.3 on a scale of 0.0 (transparent) to 1.0 (opaque).  
* adding `color = "orange"` to `geom_smooth()` changes the regression line color to orange.  
* adding `size` = 8` sets the line width (it's too wide!).  
* setting `se = FALSE` removes the standard error range from the regression.  
  
In addition to  `x`, `y`, and other `aes()` mappings, the `labs()` function sets the main labels, including the text for title, axis labels, subtitle, and caption.  Items such as axis tick marks are set by the various `scale_` functions.
  
```{r}
p + geom_point(alpha = 0.3) +
     geom_smooth(color = "orange", se=FALSE, size = 1, method = "lm") +
     scale_x_log10(labels = scales::dollar) +
  labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
  
```
  
Back to where we mapped continents to color and had multiple loess lines with se zones... We can also change the color of the se zones to match the color of the lines:  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent, fill = continent))

p + geom_point() +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```
  
    
### 3.6 Aesthetics Can be Mapped per Geom 
  
We may instead want just one regression line, but maintain the color coding of points by continent. 
  
geoms inherit their mappings from `ggplot()` by default.  We can change this by specifying different aesthetics for each `geom`.  We still use `mapping = aes()`, but now in the `geom_` functions as well: 
  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(color = continent)) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```  
  
We can also plot a continuous scale, by mapping to the `color` aesthetic.  For example:  

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```

  
### 3.7 Save Your Work 
  
Set the default size of plots within the .Rmd document by setting an option in the first chunk of code.  This tells R to make 8" x 5" figures:  
```{r}
knitr::opts_chunk$set(fig.width = 8, fig.height = 5)
```
  
To change the size of a particular figure without changing the default setting, add the option to any code chunk within the braces:  
  
```{r example, fig.width = 4, fig.height=2.5}
p + geom_point()
```
  
When working with `ggplot`, the easiest way to save a figure is via `ggsave()`.  To save the most recent picture, we provide the name we want to save as:  
  
```{r}
ggsave(filename = "myfilename.svg")  
```
  
We can change the format of the file by simply changing the extension:  
  
```{r}
ggsave(filename = "myfilename.png")
```
  
No need to include `filename =` if the file name is the first argument you give `ggsave()`.  
  
We can also pass a **plot object** to `ggsave()`:  
  
```{r}
p_out <- p + geom_point() +
  geom_smooth(method = "loess") +
  scale_x_log10()

ggsave("my_figure2.pdf", plot = p_out)
```
  
When saving our work, it's best to have separate folders inside the main project file for data and figures.  When saving figures, we can use the `here` library to avoid typing complete file paths.  Here's how it works:       

```{r}
here()
```
  
Now we can save to our "figures" folder using `here`:  
  
```{r}
ggsave(here("figures", "my_figure2.pdf"), plot = p_out)
```
  
When saving files, keep in mind two broad categories: *vector* formats, and *raster* formats:

* **vector** formats include PDF, SVG.  These are stored as a set of image instructions, which the viewing software interprets.  These formats are good for resizing, say for white papers.  
* **raster** formats include JPG (compressed raster) and PNG (lossless compression).  These are usually for web display, and not easily re-sized.  
  
In general, it's wise to save images in multiple formats and different sizes.  Use the `scale` argument in `ggsave()` to help:  
```{r}
ggsave(here("figures", "my_figure3.pdf"), plot = p_out, scale = 5)
```

    
### 3.8 Where to Go Next  
  
* What happens when we place `geom_smooth()` before `geom_point()`?  What does this tell us about how the plot is drawn?  How might this be useful?  
```{r}
p + 
  geom_smooth(method = "loess") +
  geom_point() +
  scale_x_log10()
```
  
  + This places the regression line under the scatter plots.  
  
* Change the mappings in the aes() function to plot life expectancy against population rather than GDP.
  + How does this look?  
  + What does it tell us about the unit of observation?  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = pop, y = lifeExp))

p + 
  geom_smooth(method = "loess") +
  geom_point() +
  scale_x_log10()
```

  #We can see individual countries population and life expectancy increasing over time.

* Try some alternative scale mappings such as `scale_x_sqrt()` and `scale_x_reverse()`.  Try the same for y-axis scale mappings:  
  
```{r}
p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_sqrt(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```
  
*(Kuwait is the outlier)*  
  
  
```{r}
p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_reverse(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```
  
* What if we map `color` to `year` rather than to `continent`?  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_point(mapping = aes(color = year)) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```
  + Year is not a **factor**, it's an **integer**... But we can convert it to a factor! :  
  
```{r}
p + geom_point(mapping = aes(color = factor(year))) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```
  

## Chapter 4: Show the Right Numbers  
  
* *grouping*  tells ggplot more about the internal structure of our data  
* *faceting* breaks our data into groups for plotting  
* *transforming* data can be done inside of the *geom* functions with the associtated *stat* functions.  
  
### 4.2:  Grouped Data and the "Group" Aesthetic  
  
We can use the `group` aesthetic to tell ggplot explicitly about country-level structure:  
  
```{r}
p <- ggplot(gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(aes(group = country))
```
  
(Kuwait is the outlier)  
  
The plot is extremely busy, so we'll *facet* (group) the data by continent to make small multiples.  This allows a lot of data to be presented compactly in a comparable fashion.  

In this case, we use `facet_wrap()` function to group data by continent.  The `facet_wrap()` function can take several arguments, the most important of which is the first (it uses the tilde character ~).  
  
```{r}
p + 
  geom_line(aes(group = country )) +
  facet_wrap(~ continent)
```
  
Each facet is labeled at the top.  We can use the `ncol` argument to control the number of columns.  Since we only have 5 continents, we can probably display on 1 row.  We can also lighten the individual country lines, add a wide trend line, make the y-axis log scaled, add $ labels:  
  
```{r}
p + 
  geom_line(color = "gray70", aes(group = country )) +
  geom_smooth(size = 1.1, method = loess, se = FALSE) +
  scale_y_log10(labels = scales::dollar) +
  facet_wrap(~ continent, ncol = 5) +
  labs(x = "Year",
       y = "GDP per Capita",
       title = "GDP per Capita on 5 Continents")
```
  
`facet_wrap()` is best used when dealing with a single categorical variable.  When we want to group by 2 or more, `facet_grid()` is a better choice.

The 2016 Global Social Survey, or `gss_sm` is a small subset of data from a wide social survey.  Here's some info:  
  
```{r}
?gss_sm

str(gss_sm)

summary(gss_sm)

glimpse(gss_sm)

head(gss_sm, 10)

tail(gss_sm, 10)
```
  
We can make a smoothed scatterplot of the relationship between age and number of children:  
  
```{r}
p <- ggplot(data=gss_sm, mapping = aes(x = age, y = childs))

p + geom_point(alpha = 0.2) +
  geom_smooth()
```
  
    
Now, we facet by sex and race:    
```{r}
p + geom_point(alpha = 0.2) +
  geom_smooth() +
  facet_grid(sex ~ race)
```
  
We could add more than 2 categories to facet on:  

```{r}
p + geom_point(alpha = 0.2) +
  geom_smooth() +
  facet_grid(sex ~ race + degree)
```






## Chapter 5: Graph Tables, Make Labels, Add Notes

```{r}

```

## Chapter 6: Work with Models

```{r}

```

## Chapter 7: Draw Maps

```{r}

```


## Chapter 8: Refine your Plots

```{r}

```


