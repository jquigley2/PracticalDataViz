---
title: "Data Visualization Notes"
author: "Jon Quigley"
date: "2020-02-26"
output: html_document
---
   
## Data Visualization Notes

This is a starter RMarkdown template to accompany *Data Visualization* (Princeton University Press, 2019). You can use it to take notes, write your code, and produce a good-looking, reproducible document that records the work you have done. At the very top of the file is a section of *metadata*, or information about what the file is and what it does. The metadata is delimited by three dashes at the start and another three at the end. You should change the title, author, and date to the values that suit you. Keep the `output` line as it is for now, however. Each line in the metadata has a structure. First the *key* ("title", "author", etc), then a colon, and then the *value* associated with the key.  

## This is an RMarkdown File 

Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

**R Shortcuts:**

- *Alt + -* for assignment operator <-  
  
  
  
**R Mardown tips 'n Tricks:**

- Denote a header with #
- Denote subheader with ##
- Denote italics with *this*
- Denote **bold** with this
- Denote `verbatim` like this
- 1. for a list
- Footnotes like this.[^1]
- `[^1]: the actual footnote like this`


- *Ctrl + Alt + I* to insert code chunks
- *Alt + Enter* to run current line of code
- *Alt + Shift + K* for help window

(more here: http://rmarkdown.rstudio.com,  
and here: https://ismayc.github.io/thesisdown_book/1-rmd-basics.html)

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. A *code chunk* is a specially delimited section of the file. You can add one by moving the cursor to a blank line choosing Code > Insert Chunk from the RStudio menu. When you do, an empty chunk will appear:

```{r}


```

Code chunks are delimited by three backticks (found to the left of the 1 key on US and UK keyboards) at the start and end. The opening backticks also have a pair of braces and the letter `r`, to indicate what language the chunk is written in. You write your code inside the code chunks. Write your notes and other material around them, as here. 

## Before you Begin

To install the tidyverse, make sure you have an Internet connection. Then *manually* run the code in the chunk below. If you knit the document if will be skipped. We do this because you only need to install these packages once, not every time you run this file. Either knit the chunk using the little green "play" arrow to the right of the chunk area, or copy and paste the text into the console window.

```{r install, eval = FALSE}

## This code will not be evaluated automatically.
## (Notice the eval = FALSE declaration in the options section of the
## code chunk)

my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "viridis", "viridisLite", "devtools")

install.packages(my_packages, repos = "http://cran.rstudio.com")

```

## Set Up Your Project and Load Libraries

To begin we must load some libraries we will be using. If we do not load them, R will not be able to find the functions contained in these libraries. The tidyverse includes ggplot and other tools. We also load the socviz and gapminder libraries.

```{r setup, include=FALSE}

## By defult, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(echo = TRUE) 

## Set the default size of figures
knitr::opts_chunk$set(fig.width=8, fig.height=5)  

## Load the libraries we will be using
library(gapminder)
library(here)
library(socviz)
library(tidyverse)

```

Notice that here, the braces at the start of the code chunk have some additional options set in them. There is the language, `r`, as before. This is required. Then there is the word `setup`, which is a label for your code chunk. Labels are useful to briefly say what the chunk does. Label names must be unique (no two chunks in the same document can have the same label) and cannot contain spaces. Then, after the comma, an option is set: `include=FALSE`. This tells R to run this code but not to include the output in the final document. 


When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r look}
gapminder
```
  
The remainder of this document contains the chapter headings for the book, and an empty code chunk in each section to get you started. Try knitting this document now by clicking the "Knit" button in the RStudio toolbar, or choosing File > Knit Document from the RStudio menu.

## Chapter 1:  Look at Data
```{r}

```
  
## Chapter 2: Get Started
  
Load the *tidyverse* library:  
```{r}
library(tidyverse)
```
  
Load the *socviz* library:
```{r}
library(socviz)
```
  
### Chapter 2.3: ****************
Almost verything is an **object**.
  
The **command** `c()` is a **function** - "c" is short for concatenate:
```{r}
c(1,2,3,1,3,5,25)
```
  
Assign these results to an **object**:
```{r}
my_numbers<-c(1,2,3,1,3,5,25)

your_numbers<-c(5,31,71,1,3,21,6)
```
  
The object `my_numbers` is a numeric **vector**:
```{r}
my_numbers
```
  
`mean()` is a function which acts on a vector of numbers

```{r}
mean(x = my_numbers)

mean(x = your_numbers)
```
  
We don't need to specify the name "x" for the function to work:
```{r}
mean(my_numbers)


summary(my_numbers)
```
  
We can **assign** the result of a function to an object
```{r}
my_summary <- summary(my_numbers)

my_summary
```
  
Functions come in **packages**:
```{r}
table(my_numbers) #a table of counts

sd(my_numbers) #standard deviation
```
  
Vectorized operations:
```{r}
my_numbers * 5 #multiplies each number in the vector by 5

my_numbers + 1 #adds one to each number in the vector
 
my_numbers + my_numbers #adds the vectors
```
  
Ask for the class of an object:
```{r}
class(my_numbers)

class(my_summary)

class(summary)
```
  
We may change the class after certain operations:
```{r}
my_new_vector <- c(my_numbers, "apple")

my_new_vector
```
  
Adding the word apple to our list of numbers changed the class:  
```{r}
class(my_new_vector)
```

**Data frames** are the most common kind of data object.  Date frames are rectangular table with rows (observations) and columns (variables).  
Columns in data frames can be different types:
  
```{r}
titanic
?titanic
class(titanic)
summary(titanic)
```
  
Access a named column with a `$` operator:
```{r}
titanic$percent
```
  
Access first two observations (rows), and all variables (columns):  
```{r}
titanic[1:2,]
```
  
Access observations for females only:
```{r}
subset(titanic, sex == 'female')
```
  
Access observations for females only, where percent < 10:
```{r}
subset(titanic, sex == 'female' & percent < 10)
```

Access observations for females only, where percent < 10, but keep only sex and fate variables:
```{r}
subset(titanic, sex == 'female' & percent < 10, select=c(fate, sex))
```

See Appendix 1 for more info on selecting elements.  
  
A **tibble** is an enhanced kind of data frame.  
  
Convert a data frame to a tibble:
```{r}
titanic_tb <- as_tibble(titanic)

titanic_tb
```

The `str()` function lets us see what is inside an object:
```{r}
str(titanic_tb)
```
  
  
  
### Chapter 2.4***************
In ggplot, we'll build plots one element at a tim by adding expressions.  

Be careful to place "+" at the end of the lines and not the beginning:
```{r}
ggplot(data = mpg, aes(x = displ, y = hwy)) + 
     geom_point() 
```

### Chapter 2.5 Get Data into R***************
Use `read_csv()` from the readr package (it's in the tidyverse).  
  
We can read in a local file or a remote file.  For example:

```{r}
url <- "https://cdn.rawgit.com/kjhealy/viz-organdata/master/organdonation.csv"

organs <- read_csv(url)
```
  
When preparing data for use in R, it's best if in **Tidy** format.

https://r4ds.had.co.nz/tidy-data.html

- each variable is a column
- each observation is a row
- each type of observational unit forms a table  

Untidy census table:  
```{r}
edu
```

Use `gather()` to transform the schooling variables into a **key-value arrangement**.  
Key is the underlying variable, value is the value of the observation:
```{r}
edu_tidy <- gather(data = edu,
                   key = school,
                   value = freq, 
                   elem4 : coll4)

head(edu_tidy, 10)
tail(edu_tidy, 10)
```
  
### Chapter 2.6 First Plot***************
```{r}
library(gapminder)

gapminder

p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point()

```


## Chapter 3: Make a Plot  
  
### 3.2 Tidy Data  
Tidyverse tools like to see **long-format** data.  
  
### 3.3 Mappings Link Data to Things We See
  
We can use a recipe for creating each plot in R:  
  
1. Start with **tidy** data - usually a data frame or a tibble  
2. tell the core *ggplot* function what our data is, and what the *mappings* are (and assign to "p")  
3. Choose a plot type, or *geom* and add it to "p"  
4. Add more features, such as adjusted elements, adjusted scales, title and labels, etc...  
    
Remind ourselves what `gapminder` data looks like:
```{r}
str(gapminder)
head(gapminder, 10)
tail(gapminder, 10)
```
  
Now, let's follow the recipe:  
2.  tell the core *ggplot* function what our *data* is (and assign it "p"), and what the *mappings* are:  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
```
  
The `mapping = aes()` argument links variables to to things we'll see on the plot.  
These mappings can include items such as color, shape, size, and line characteristics.  

3. Choose a plot type, or *geom* and add it to "p"   

Here, we use the data in a scatterplot:
```{r}
p +
     geom_point()
```
  
### 3.4 Build Plots Layer by Layer

Let's try a different *geom_* function:  
```{r}
p +
     geom_smooth()
```
  
Here, we can see the geom_ function has some special qualities by default.  
It no longer maps the individual points; instead it's calculated a smooth line with a shaded area equal to the standard error.  By default, the smoothed line is determined via *gam* method - general additive model.  
  
If we want to add the points back in, we can add 'geom_point()' back in:  
```{r}
p +
     geom_smooth() +
     geom_point()
```
  
We can also change from the default gam method to a linear model fit:  
```{r}
p +
     geom_smooth(method = "lm") +
     geom_point()
```
  
We can see wo bunched GDP is on the left hand side of the x-axis.  By applying a log scale to the x-axis, we can improve the clarity:  
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_x_log10()
```
  
The log xform is applied prior to the scaling function.  
  
There are a number of scale xform we can apply; each has its own name, and reference the axis it applies to:
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_y_log10()
```
    
Next, we'd want to add axis labels, a title, and clean up the tick mark formatting.  

Labels on tick marks are controlled through the *scale_* functions.  
  
The `scales` package contains some useful formats. Rather than load the package with `library(scales)', we can grab the function directly from the library using the syntax `thepackage::thefunction'.  
  
To do this for the x-axis:  
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_x_log10(labels = scales::dollar)
```
  
In general regarding scale transforms:  
1. we can directly xform by adding *scale_y_* or *scale_x_* to the plot.  
2. then, we can give this *scale_* function a *labels* argument.  
    
      
### 3.5 Mapping Aesthetics vs. Setting Them  
  
An *aesthetic mapping* specifies which color, shape, size, etc... a varibale will be represented as.  We can map a variable like this:  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent))

p + geom_point() +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar)
```
  
If we wanted to turn all points in the plot purple, we do not assign the color purple in the aesthetic; we set it in the geom_():  

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(color = "purple") +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar)
```

Now, we're no longer assigning continents to colors, we're simply coloring all points purple - so we also get only one regression line.  
  
`geom_()` functions can take other inputs which impact appearance without being mapped to aesthetic.  
  
```{r}
p + geom_point(alpha = 0.3) +
     geom_smooth(color = "orange", se=FALSE, size = 8, method = "lm") +
     scale_x_log10(labels = scales::dollar)
```
  
* adding `alpha = 0.3` to `geom_point` sets the tranparency of the dots to 0.3 on a scale of 0.0 (transparent) to 1.0 (opaque).  
* adding `color = "orange"` to `geom_smooth()` changes the regression line color to orange.  
* adding `size` = 8` sets the line width (it's too wide!).  
* setting `se = FALSE` removes the standard error range from the regression.  
  
In addition to  `x`, `y`, and other `aes()` mappings, the `labs()` function sets the main labels, including the text for title, axis labels, subtitle, and caption.  Items such as axis tick marks are set by the various `scale_` functions.
  
```{r}
p + geom_point(alpha = 0.3) +
     geom_smooth(color = "orange", se=FALSE, size = 1, method = "lm") +
     scale_x_log10(labels = scales::dollar) +
  labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
  
```
  
Back to where we mapped continents to color and had multiple loess lines with se zones... We can also change the color of the se zones to match the color of the lines:  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent, fill = continent))

p + geom_point() +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```
  
    
### 3.6 Aesthetics Can be Mapped per Geom 
  
We may instead want just one regression line, but maintain the color coding of points by continent. 
  
geoms inherit their mappings from `ggplot()` by default.  We can change this by specifying different aesthetics for each `geom`.  We still use `mapping = aes()`, but now in the `geom_` functions as well: 
  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(color = continent)) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```  
  
We can also plot a continuous scale, by mapping to the `color` aesthetic.  For example:  

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```

  
### 3.7 Save Your Work 
  
Set the default size of plots within the .Rmd document by setting an option in the first chunk of code.  This tells R to make 8" x 5" figures:  
```{r}
knitr::opts_chunk$set(fig.width = 8, fig.height = 5)
```
  
To change the size of a particular figure without changing the default setting, add the option to any code chunk within the braces:  
  
```{r example, fig.width = 4, fig.height=2.5}
p + geom_point()
```
  


```{r}
here()
```
    
      
### 3.8 Where to Go Next  
  


  


## Chapter 5: Graph Tables, Make Labels, Add Notes

```{r}

```

## Chapter 6: Work with Models

```{r}

```

## Chapter 7: Draw Maps

```{r}

```


## Chapter 8: Refine your Plots

```{r}

```


