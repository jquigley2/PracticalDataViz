---
title: "Data Visualization Notes"
author: "Jon Quigley"
date: '2020-02-26'
output:
  pdf_document: default
  html_document: default
  word_document: default
---
   
## Data Visualization Notes

This is a starter RMarkdown template to accompany *Data Visualization* (Princeton University Press, 2019). You can use it to take notes, write your code, and produce a good-looking, reproducible document that records the work you have done. At the very top of the file is a section of *metadata*, or information about what the file is and what it does. The metadata is delimited by three dashes at the start and another three at the end. You should change the title, author, and date to the values that suit you. Keep the `output` line as it is for now, however. Each line in the metadata has a structure. First the *key* ("title", "author", etc), then a colon, and then the *value* associated with the key.  

## This is an RMarkdown File 

Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

**R Shortcuts:**

- *Alt + -* for assignment operator <-  
  
  
**R Markdown tips 'n Tricks:**

- Denote a header with #
- Denote subheader with ##
- Denote italics with *this*
- Denote **bold** with this
- Denote `verbatim` like this
- 1. for a list
- Footnotes like this.[^1]
- `[^1]: the actual footnote like this`


- *Ctrl + Alt + I* to insert code chunks
- *Alt + Enter* to run current line of code
- *Alt + Shift + K* for help window

(more here: http://rmarkdown.rstudio.com,  
and here: https://ismayc.github.io/thesisdown_book/1-rmd-basics.html)

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. A *code chunk* is a specially delimited section of the file. You can add one by moving the cursor to a blank line choosing Code > Insert Chunk from the RStudio menu. When you do, an empty chunk will appear:

```{r}


```

Code chunks are delimited by three backticks (found to the left of the 1 key on US and UK keyboards) at the start and end. The opening backticks also have a pair of braces and the letter `r`, to indicate what language the chunk is written in. You write your code inside the code chunks. Write your notes and other material around them, as here. 

## Before you Begin

To install the tidyverse, make sure you have an Internet connection. Then *manually* run the code in the chunk below. If you knit the document if will be skipped. We do this because you only need to install these packages once, not every time you run this file. Either knit the chunk using the little green "play" arrow to the right of the chunk area, or copy and paste the text into the console window.

```{r install, eval = FALSE}

## This code will not be evaluated automatically.
## (Notice the eval = FALSE declaration in the options section of the
## code chunk)

my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "svglite", "viridis", "viridisLite", "devtools")

install.packages(my_packages, repos = "http://cran.rstudio.com")

```

## Set Up Your Project and Load Libraries

To begin we must load some libraries we will be using. If we do not load them, R will not be able to find the functions contained in these libraries. The tidyverse includes ggplot and other tools. We also load the socviz and gapminder libraries.

```{r setup, include=FALSE}

## By defult, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(echo = TRUE) 

## Set the default size of figures
knitr::opts_chunk$set(fig.width=8, fig.height=5)  

## Load the libraries we will be using
library(gapminder)
library(here)
library(socviz)
library(tidyverse)
library(svglite)

```

Notice that here, the braces at the start of the code chunk have some additional options set in them. There is the language, `r`, as before. This is required. Then there is the word `setup`, which is a label for your code chunk. Labels are useful to briefly say what the chunk does. Label names must be unique (no two chunks in the same document can have the same label) and cannot contain spaces. Then, after the comma, an option is set: `include=FALSE`. This tells R to run this code but not to include the output in the final document. 


When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r look}
gapminder
glimpse(gapminder)
```
  
The remainder of this document contains the chapter headings for the book, and an empty code chunk in each section to get you started. Try knitting this document now by clicking the "Knit" button in the RStudio toolbar, or choosing File > Knit Document from the RStudio menu.

## Chapter 1:  Look at Data
```{r}

```
  
## Chapter 2: Get Started
  
Load the *tidyverse* library:  
```{r}
library(tidyverse)
```
  
Load the *socviz* library:
```{r}
library(socviz)
```
  
### Chapter 2.3: ****************
Almost everything is an **object**.
  
The **command** `c()` is a **function** - "c" is short for concatenate:
```{r}
c(1,2,3,1,3,5,25)
```
  
Assign these results to an **object**:
```{r}
my_numbers<-c(1,2,3,1,3,5,25)

your_numbers<-c(5,31,71,1,3,21,6)
```
  
The object `my_numbers` is a numeric **vector**:
```{r}
my_numbers
```
  
`mean()` is a function which acts on a vector of numbers

```{r}
mean(x = my_numbers)

mean(x = your_numbers)
```
  
We don't need to specify the name "x" for the function to work:
```{r}
mean(my_numbers)


summary(my_numbers)
```
  
We can **assign** the result of a function to an object
```{r}
my_summary <- summary(my_numbers)

my_summary
```
  
Functions come in **packages**:
```{r}
table(my_numbers) #a table of counts

sd(my_numbers) #standard deviation
```
  
Vectorized operations:
```{r}
my_numbers * 5 #multiplies each number in the vector by 5

my_numbers + 1 #adds one to each number in the vector
 
my_numbers + my_numbers #adds the vectors
```
  
Ask for the class of an object:
```{r}
class(my_numbers)

class(my_summary)

class(summary)
```
  
We may change the class after certain operations:
```{r}
my_new_vector <- c(my_numbers, "apple")

my_new_vector
```
  
Adding the word apple to our list of numbers changed the class:  
```{r}
class(my_new_vector)
```

**Data frames** are the most common kind of data object.  Date frames are rectangular table with rows (observations) and columns (variables).  
Columns in data frames can be different types:
  
```{r}
titanic
?titanic
class(titanic)
summary(titanic)
```
  
Access a named column with a `$` operator:
```{r}
titanic$percent
```
  
Access first two observations (rows), and all variables (columns):  
```{r}
titanic[1:2,]
```
  
Access observations for females only:
```{r}
subset(titanic, sex == 'female')
```
  
Access observations for females only, where percent < 10:
```{r}
subset(titanic, sex == 'female' & percent < 10)
```

Access observations for females only, where percent < 10, but keep only sex and fate variables:
```{r}
subset(titanic, sex == 'female' & percent < 10, select=c(fate, sex))
```

See Appendix 1 for more info on selecting elements.  
  
A **tibble** is an enhanced kind of data frame.  
  
Convert a data frame to a tibble:
```{r}
titanic_tb <- as_tibble(titanic)

titanic_tb
```

The `str()` function -*structure* - lets us see what is inside an object:
```{r}
str(titanic_tb)

str(my_numbers)

str(my_summary)
```
  
### Chapter 2.4***************
In ggplot, we'll build plots one element at a time by adding expressions.  

Be careful to place "+" at the end of the lines and not the beginning:
```{r}
ggplot(data = mpg, aes(x = displ, y = hwy)) + 
     geom_point() 
```

### Chapter 2.5 Get Data into R***************
Use `read_csv()` from the readr package (it's in the tidyverse).  
  
We can read in a local file or a remote file.  For example:

```{r}
url <- "https://cdn.rawgit.com/kjhealy/viz-organdata/master/organdonation.csv"

organs <- read_csv(url)
```
  
When preparing data for use in R, it's best if in **Tidy** format.

https://r4ds.had.co.nz/tidy-data.html

- each variable is a column
- each observation is a row
- each type of observational unit forms a table  

Untidy census table:  
```{r}
edu
```

Use `gather()` to transform the schooling variables into a **key-value arrangement**.  
Key is the underlying variable, value is the value of the observation:
```{r}
edu_tidy <- gather(data = edu,
                   key = school,
                   value = freq, 
                   elem4 : coll4)

head(edu_tidy, 10)
tail(edu_tidy, 10)
```
  
### Chapter 2.6 First Plot***************
```{r}
library(gapminder)

gapminder

p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point()

```


## Chapter 3: Make a Plot  
In *ggplot*, you begin by telling the function what your data is, and how the variables map to the aesthetics. Then, take the result and indicate the general type of plot.  The rest is "just" details.   
  
  
### 3.2 Tidy Data  
Tidyverse tools like to see **long-format** data.  
  
### 3.3 Mappings Link Data to Things We See
  
We can use a recipe for creating each plot in R:  
  
1. Start with **tidy** data - usually a data frame or a tibble  
2. tell the core *ggplot* function what our data is, and what the *mappings* are (and assign to "p")  
3. Choose a plot type, or *geom* and add it to "p"  
4. Add more features, such as adjusted elements, adjusted scales, title and labels, etc...  
    
Remind ourselves what `gapminder` data looks like:
```{r}
str(gapminder)
head(gapminder, 10)
tail(gapminder, 10)
```
  
Now, let's follow the recipe:  
2.  tell the core *ggplot* function what our *data* is (and assign it to "p"), and what the *mappings* are:  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
```
  
The `mapping = aes()` argument links variables to to things we'll see on the plot.  
These mappings can include items such as color, shape, size, and line characteristics.  

3. Choose a plot type, or *geom* and add it to "p"   

Here, we use the data in a scatterplot:
```{r}
p +
     geom_point()
```
  
### 3.4 Build Plots Layer by Layer

Let's try a different *geom_* function:  
```{r}
p +
     geom_smooth()
```
  
Here, we can see the geom_ function has some special qualities by default.  
It no longer maps the individual points; instead it's calculated a smooth line with a shaded area equal to the standard error.  By default, the smoothed line is determined via *gam* method - general additive model.  

[GAM (Generalized Additive Model)] https://en.wikipedia.org/wiki/Generalized_additive_model  
  
If we want to add the points back in, we can add 'geom_point()' back in:  
```{r}
p +
     geom_smooth() +
     geom_point()
```
  
We can also change from the default gam method to a linear model fit:  
```{r}
p +
     geom_smooth(method = "lm") +
     geom_point()
```
  
  
We can see how bunched GDP is on the left hand side of the x-axis.  By applying a log scale to the x-axis, we can improve the clarity:  
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_x_log10()
```
  
The log xform is applied prior to the scaling function.  
  
There are a number of scale xform we can apply; each has its own name, and reference the axis it applies to:
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_y_log10()
```
    
Next, we'd want to add axis labels, a title, and clean up the tick mark formatting.  

Labels on tick marks are controlled through the *scale_* functions.  
  
The `scales` package contains some useful formats. Rather than load the package with `library(scales)', we can grab the function directly from the library using the syntax `thepackage::thefunction'.  
  
To do this for the x-axis:  
```{r}
p +
     geom_smooth(method = "gam") +
     geom_point() +
     scale_x_log10(labels = scales::dollar)
```
  
In general regarding scale transforms:  
1. we can directly xform by adding *scale_y_* or *scale_x_* to the plot.  
2. then, we can give this *scale_* function a *labels* argument.  
    
      
### 3.5 Mapping Aesthetics vs. Setting Them  
  
An *aesthetic mapping* specifies which color, shape, size, etc... a variable will be represented as.  We can map a variable like this:  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent))

p + geom_point() +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar)
```

[LOESS (Locally Estimated Scatterplot Smoothing)] https://en.wikipedia.org/wiki/Local_regression 
  
If we wanted to turn all points in the plot purple, we do not assign the color purple in the aesthetic; we set it in the geom_():  

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(color = "purple") +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar)
```

Now, we're no longer assigning continents to colors, we're simply coloring all points purple - so we also get only one regression line.  
  
`geom_()` functions can take other inputs which impact appearance without being mapped to aesthetic.  
  
```{r}
p + geom_point(alpha = 0.3) +
     geom_smooth(color = "orange", se=FALSE, size = 8, method = "lm") +
     scale_x_log10(labels = scales::dollar)
```
  
* adding `alpha = 0.3` to `geom_point` sets the tranparency of the dots to 0.3 on a scale of 0.0 (transparent) to 1.0 (opaque).  
* adding `color = "orange"` to `geom_smooth()` changes the regression line color to orange.  
* adding `size` = 8` sets the line width (it's too wide!).  
* setting `se = FALSE` removes the standard error range from the regression.  
  
In addition to  `x`, `y`, and other `aes()` mappings, the `labs()` function sets the main labels, including the text for title, axis labels, subtitle, and caption.  Items such as axis tick marks are set by the various `scale_` functions.
  
```{r}
p + geom_point(alpha = 0.3) +
     geom_smooth(color = "orange", se=FALSE, size = 1, method = "lm") +
     scale_x_log10(labels = scales::dollar) +
  labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
  
```
  
Back to where we mapped continents to color and had multiple loess lines with se zones... We can also change the color of the se zones to match the color of the lines:  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent, fill = continent))

p + geom_point() +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```
  
    
### 3.6 Aesthetics Can be Mapped per Geom 
  
We may instead want just one regression line, but maintain the color coding of points by continent. 
  
geoms inherit their mappings from `ggplot()` by default.  We can change this by specifying different aesthetics for each `geom`.  We still use `mapping = aes()`, but now in the `geom_` functions as well: 
  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(color = continent)) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```  
  
We can also plot a continuous scale, by mapping to the `color` aesthetic.  For example:  

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```

  
### 3.7 Save Your Work 
  
Set the default size of plots within the .Rmd document by setting an option in the first chunk of code.  This tells R to make 8" x 5" figures:  
```{r}
knitr::opts_chunk$set(fig.width = 8, fig.height = 5)
```
  
To change the size of a particular figure without changing the default setting, add the option to any code chunk within the braces:  
  
```{r example, fig.width = 4, fig.height=5}
p + geom_point()
```
  
When working with `ggplot`, the easiest way to save a figure is via `ggsave()`.  To save the most recent picture, we provide the name we want to save as:  
  
```{r}
ggsave(filename = "myfilename.svg")  
```
  
We can change the format of the file by simply changing the extension:  
  
```{r}
ggsave(filename = "myfilename.png")
```
  
No need to include `filename =` if the file name is the first argument you give `ggsave()`.  
  
We can also pass a **plot object** to `ggsave()`:  
  
```{r}
p_out <- p + geom_point() +
  geom_smooth(method = "loess") +
  scale_x_log10()

ggsave("my_figure2.pdf", plot = p_out)
```
  
When saving our work, it's best to have separate folders inside the main project file for data and figures.  When saving figures, we can use the `here` library to avoid typing complete file paths.  Here's how it works:       

```{r}
here()
```
  
Now we can save to our "figures" folder using `here`:  
  
```{r}
ggsave(here("figures", "my_figure2.pdf"), plot = p_out)
```
  
When saving files, keep in mind two broad categories: *vector* formats, and *raster* formats:

* **vector** formats include PDF, SVG.  These are stored as a set of image instructions, which the viewing software interprets.  These formats are good for resizing, say for white papers.  
* **raster** formats include JPG (compressed raster) and PNG (lossless compression).  These are usually for web display, and not easily re-sized.  
  
In general, it's wise to save images in multiple formats and different sizes.  Use the `scale` argument in `ggsave()` to help:  
```{r}
ggsave(here("figures", "my_figure3.pdf"), plot = p_out, scale = 5)
```

    
### 3.8 Where to Go Next  
  
* What happens when we place `geom_smooth()` before `geom_point()`?  What does this tell us about how the plot is drawn?  How might this be useful?  
```{r}
p + 
  geom_smooth(method = "loess") +
  geom_point() +
  scale_x_log10()
```
  
  + This places the regression line under the scatter plots.  
  
* Change the mappings in the aes() function to plot life expectancy against population rather than GDP.
  + How does this look?  
  + What does it tell us about the unit of observation?  
  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = pop, y = lifeExp))

p + 
  geom_smooth(method = "loess") +
  geom_point() +
  scale_x_log10()
```

  #We can see individual countries population and life expectancy increasing over time.

* Try some alternative scale mappings such as `scale_x_sqrt()` and `scale_x_reverse()`.  Try the same for y-axis scale mappings:  
  
```{r}
p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_sqrt(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```
  
*(Kuwait is the outlier)*  
  
  
```{r}
p + geom_point(mapping = aes(color = log(pop))) +
     geom_smooth(method = "loess") +
     scale_x_reverse(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```
  
* What if we map `color` to `year` rather than to `continent`?  
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_point(mapping = aes(color = year)) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")

```
  + Year is not a **factor**, it's an **integer**... But we can convert it to a factor! :  
  
```{r}
p + geom_point(mapping = aes(color = factor(year))) +
     geom_smooth(method = "loess") +
     scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita",
       y = "Life Expectancy in Years",
       title = "Economic Growth & Life Expectancy",
       subtitle = "Data points are country-years",
       caption = "Source: Gapminder")
```
  

## Chapter 4: Show the Right Numbers  
  
* *grouping*  tells ggplot more about the internal structure of our data  
* *faceting* breaks our data into groups for plotting  
* *transforming* data can be done inside of the *geom* functions with the associated *stat* functions.  
  
### 4.2:  Grouped Data and the "Group" Aesthetic  
  
We can use the `group` aesthetic to tell ggplot explicitly about country-level structure:  
  
```{r}
p <- ggplot(gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(aes(group = country))
```
  
(Kuwait is the outlier)  
  
The plot is extremely busy, so we'll *facet* (group) the data by continent to make small multiples.  This allows a lot of data to be presented compactly in a comparable fashion.  

In this case, we use `facet_wrap()` function to group data by continent.  The `facet_wrap()` function can take several arguments, the most important of which is the first (it uses the tilde character ~).  
  
```{r}
p + 
  geom_line(aes(group = country )) +
  facet_wrap(~ continent)
```
  
Each facet is labeled at the top.  We can use the `ncol` argument to control the number of columns.  Since we only have 5 continents, we can probably display on 1 row.  We can also lighten the individual country lines, add a wide trend line, make the y-axis log scaled, add $ labels:  
  
```{r}
p + 
  geom_line(color = "gray70", aes(group = country )) +
  geom_smooth(size = 1.1, method = loess, se = FALSE) +
  scale_y_log10(labels = scales::dollar) +
  facet_wrap(~ continent, ncol = 5) +
  labs(x = "Year",
       y = "GDP per Capita",
       title = "GDP per Capita on 5 Continents")
```
  
`facet_wrap()` is best used when dealing with a single categorical variable.  When we want to group by 2 or more, `facet_grid()` is a better choice.

The 2016 Global Social Survey, or `gss_sm` is a small subset of data from a wide social survey.  Here's some info:  
  
```{r}
?gss_sm

str(gss_sm)

summary(gss_sm)

glimpse(gss_sm)

head(gss_sm, 10)

tail(gss_sm, 10)
```
  
We can make a smoothed scatterplot of the relationship between age and number of children:  
  
```{r}
p <- ggplot(data=gss_sm, mapping = aes(x = age, y = childs))

p + geom_point(alpha = 0.2) +
  geom_smooth()
```
  
    
Now, we facet by sex and race:    
```{r}
p + geom_point(alpha = 0.2) +
  geom_smooth() +
  facet_grid(sex ~ race)
```
  
We could add more than 2 categories to facet on:  

```{r}
p + geom_point(alpha = 0.2) +
  geom_smooth() +
  facet_grid(sex ~ race + degree)
```
This obviously becomes very difficult to read, however!

### 4.4 Geoms Can Transform Data
Some geoms simply plot the data on a figure, others do more work prior to plotting.  All `geom_()` functions have associated `stat_()` function that it uses by default, and *vice versa*.  However, at times we may want to apply a different statistic.

For example, `geom_bar()` uses the `stat_count()` function by default.  `stat_count()` calculates two variables, `count` and `prop` (for proportion).  `geom_bar()` uses the `count` statistic by default:
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion))

p + geom_bar()
```
  
If we want the chart to instead return the proportion of total population in each region, we'll need to use the `prop` statistic instead.

When ggplot calculates the count or proportion, it returns temporary variables for use in the plot.  These temp variables' names begin and end with two periods: `..prop..`.
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion))

p + geom_bar(mapping = aes(y = ..prop..))
```
  
This isn't quite right... We don't want the proportion of each region to itself, we want the proportion of each region to the whole.  So, not 4 groups, but one!:
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion))

p + geom_bar(mapping = aes(y = ..prop.., group = 1))
```

Religion is another variable in the `gss_sm` survey:

```{r}
table(gss_sm$religion)
```
  
To graph this, we want religions on the x-axis, and the bars colored by religion:  

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = religion, color = religion))

p + geom_bar()
```
  
This only places color outlines on the bars.  We want the **fill** to be color as well.  To accomplish this, we need to map the `religion` variable to `fill`.:  
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = religion, fill = religion))

p + geom_bar()
```
  
This bar chart shows a legend by default.  However, since the x-axis already shows the `religion` categories, the legend is redundant.  We can remove this by setting the `guides()` function to false:  
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = religion, fill = religion))

p + geom_bar() + guides(fill = FALSE)
```
  
### 4.5 Frequency Plots the Slightly Awkward Way
  
A better use of the `fill` aesthetic with `geom_bar()` is cross-classifying two variables, as in a count of proportions.

For example, we want to look at religious preferences by region. With `geom_bar()`, the output is controlled by the `position` argument.

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar()
```
  
The default output is a stacked bar chart, with counts on the y-axis.  This makes the relative position of any one religion difficult to compare across regions.  It's preferable to show the proportions within each region.  We can achieve this by setting the `position` argument to "`fill`".  
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "fill")
```
  
This gives us the ability to compare proportions, but we lose sense of what proportion of each religion is found in each region.  To better see that, we could do regional groups with bars for each religion using `position = "dodge"`.  

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "dodge", mapping = aes(y = ..prop.., group = religion)) #dodge forces data to miss each other
```
  
We can also facet by region, and show the proportion within each region:
```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "dodge", mapping = aes(y = ..prop.., group = religion)) 
```


### 4.6 Histograms and Density Plots
  
A histogram summarizes a continuous variable by chopping into bins and counting the observations within each bin.

We can make a histogram showing the distribution of the size of counties in the Midwest (from the `midwest' data set in ggplot):

str(midwest)
summary(midwest)
glimpse(midwest)

```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))
p + geom_histogram() #function will select a number of bins based on rule of thumb.  We can override this.
```
  
By default, 'geom_histogram()` will choose the number of bins.  We can choose the number of bins:
```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))
p + geom_histogram(bins = 10) #adjust number of bins
```
  
It's also possible to compare several variables at once by using the `fill` mapping:
```{r}
oh_wi <- c("OH", "WI") #create character vector

p <- ggplot(data = subset(midwest, subset = state %in% oh_wi), #subset midwest to include only OH, WI
            mapping = aes(x = percollege, fill = state))

p + geom_histogram(alpha = 0.4, bins = 20) #alpha sets transparency

```
  
Instead of binning and showing a historgram, we can look at kernel density using the `density()` function:

[kernel density] https://en.wikipedia.org/wiki/Kernel_density_estimation

```{r}
p <- ggplot(data = midwest, mapping = aes(x=area))
p + geom_density()
```
  
We can use `color` for the lines and `fill` for the area under the curve as well.  
```{r}
p <- ggplot(data = midwest, mapping = aes(x=area, fill = state, color = state))
p + geom_density()
```
  
Use `alpha` to reduce obstruction:  
```{r}
p <- ggplot(data = midwest, mapping = aes(x=area, fill = state, color = state))
p + geom_density(alpha = 0.3)
```

We can use geom_line(stat = density) to remove the baselines:
```{r}
p <- ggplot(data = midwest, mapping = aes(x=area))
p + geom_line(stat = "density")
```
  
As with `geom_bar()`, the count-based defaults computed by the `stat_' functions of `geom_histogram()` and `geom_density()` can return proportions.

For `geom_density()`, the `stat_density()` function can return either the default `..density..` statistic or `..scaled..`, which gives a proportional density estimate:

```{r}
p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),
            mapping = aes(x = area, fill = state, color = state))
p + geom_density(alpha = 0.3, mapping = (aes(y = ..scaled..)))
```  

### 4.7 Avoid Transforms When Necessary
  
ggplot normally makes charts by manipulating a full data set with counts, proportions, etc...  However, at times we'll be graphing a small or summary table, and we don't need ggplot to perform any calculations.  In such cases, we can tell a `geom_` to avoid doing any calculations on the data by writing `stat = 'identity'` in the `geom_()` call:

```{r}
head(titanic) #view summary table

p  <-  ggplot(data = titanic, mapping = aes(x = fate, y = percent, fill = sex))

p + 
  geom_bar(position = "dodge", stat = "identity") + 
  theme(legend.position = "top")

```
  
ggplot provides a related geom, `geom_col()`, which has the same effect but assumes `stat = "identity`.

The `position` argument in `geom_bar()` and `geom_col()` can also take the value of `"identity"`.  This means, just plot the values as given.  This allows us to plot things such as a flow of positive and negative values in a bar chart.  For example, the `oecd_sum` table in `socviz` contains info on life expectancy within the US, OECD, and relative.  
```{r}
oecd_sum
```
Here, we plot the "diff" over time, and use "hi_lo" to color the columns:

```{r}
p <- ggplot(data = oecd_sum, 
            mapping = aes(x = year, y = diff, fill = hi_lo))

p + geom_col() + guides(fill = FALSE) + #drop the unecessary legend
  labs(x = NULL, y = "Difference in Years",
       title = "US Life Expectancy Gap",
       subtitle = "Difference between US and OECD average life expectancies, 1960 - 2015",
       caption = "Data: OECD.  After a chart by Christopher Ingraham, 
       Washington Post, December 27, 2017")

```
  
### 4.8 Where to Go Next 

* Try faceting the `gapminder` data in different ways.
  + population (pop) and GDP *per capita* (gdpPercap), faceted on year
```{r}
head(gapminder)
p <- ggplot(data = gapminder, mapping = aes(x = pop, y = gdpPercap))
p + 
  geom_point() +
  facet_wrap(country ~ year)
  
```

  + population & *per capita* GDP, faceted by country.  Assign this output to an object, and output to a PDF saved in the `figures` folder.
```{r facet, fig.width = 4, fig.height=2.5}
p_out <- p + 
  geom_point() +
  facet_wrap(~ country)

ggsave(here("figures", "PopGDPCountry.pdf"), plot = p_out)

```

* Investigate the difference between a formula written as `facet_grid(sex ~ race)` and `facet_grid(~ sex + race)`.
```{r}
glimpse(gss_sm)

p <- ggplot(data = gss_sm, mapping = aes(x = age, y = kids))

p + 
  geom_point() +
  facet_grid(sex ~ race)

p + 
  geom_point() +
  facet_grid(~ sex + race)

```

* What happens when using `facet_wrap()` in a complex formula such as `facet_wrap( ~ sex + race)` instead of facet_grid?
```{r}
p + 
  geom_point() +
  facet_wrap(~ sex + race)
```

* Try using `geom_freqpoly()` instead of some of the `geom_histograms()` used above.  These use connected lines rather than bars:
```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))
p + geom_freqpoly()
```

* We can bin 2 variables at a time for a histogram with `geom_bin2d()`, which takes two mappings, x and y.
  + Try using with `gapminder` data to plot life expectancy `lifeExp` versus GDP per capita `gdpPercap`.
```{r}
?gapminder
head(gapminder)
p <- ggplot(data = gapminder, mapping = aes(x = lifeExp, y = gdpPercap))
p +
  geom_bin2d() +
  scale_y_log10(labels = scales::dollar)
```

* Density estimates can also be drawn for two variables using `geom_density_2d()`, which draws contour lines estimating the joint distribution of two variables.
  + Use to map `midwest` data, plotting `percbelowpoverty` versus `percollege` - with and without the `geom_point()` layer. 
```{r}
?geom_density2d

p <- ggplot(data = midwest, mapping = aes(x = percbelowpoverty, y = percollege))

p + geom_density2d()

p + geom_density2d() +
  geom_point()

```
  

## Chapter 5: Graph Tables, Make Labels, Add Notes
  
* Use `dplyr` to select, group, summarize, and transform data before graphing.
* Expand knowledge of geoms, and learn how to choose the appropriate one.
* Increase customization through the scale, guide and theme functions.

### 5.1 Use Pipes to Summarize Data
Using functions to do calculations can get confusing, since the code is stuffed int eh mapping function.  A better strategy is calculating the frequency table first, then plotting the result.  This also allows us to do some sanity checks on the table, rather than simply using the graphical output to find errors.

For example, if we want to determine the proportion of religions within a given region, we can use `dplyr` to operate on the `gss_sm` data frame, with it's `bigregion` and `religion` variables.  We'll use [`dplyr`] (https://dplyr.tidyverse.org/)'s special *pipe* operator, `%>%`.  (See more [here] (https://r4ds.had.co.nz/transform.html)) Data goes in one side of the pipe, actions are performed, and the result is produced.  There are four most common pipe operations:

* `group_by()` Groups the data into a nesteed structure, sucha s religions by region, or authors by publications by year
* `filter()` rows; `select()` columns *Filter* or *select* pieces of the data by row, column, or both.
* `mutate()` Mutate the data by creating new variables at the current level of grouping.  This adds new columns to the table without aggregating.
* `summarize()` Summarize or aggregate the grouped data.  This creates new variables at a higher level of grouping.  Four example, `mean()` or counts with `n()`.  This results in a smaller, summary table.
 
Let's create a table called `rel_by_region`:

```{r}
rel_by_region <-  gss_sm %>%            #creating an object
  group_by(bigregion, religion) %>%    #group the rows by bigregion and within these, by religion, and then
  summarize(N = n()) %>%                #summarize the table in a smaller table with columns bigregion, religion, and N
  mutate(freq = N / sum(N),             #within this table, use N to create 2 new columns: relative frequency (freq) and    
         pct = round((freq*100),0))     #percentage (pct) rounded to the nearest %.
    
```


### 5.2 Continuous Variables by Group or Category
```{r}

```

### 5.3 Plot Text Directly
```{r}

```

### 5.4 Label Outliers
```{r}

```

### 5.5 Write and Draw in the Plot Area
```{r}

```

### 5.6 Understanding Scales, Guides, and Themes
```{r}

```

### 5.7 Where to Go Next
```{r}

```

## Chapter 6: Work with Models

### 6.1 Show Several Fits at Once, with a Legend

```{r}

```

### 6.2 Look Inside Model Objects

```{r}

```

### 6.3 Get Model-based Graphics Right

```{r}

```

### 6.4 Generate Predictions to Graph

```{r}

```

### 6.5 Tidy Model Objects with Broom

```{r}

```

### 6.6 Grouped Analysis and List Columns

```{r}

```

### 6.7 Plot Marginal Effects

```{r}

```

### 6.8 Plots from Complex Surveys

```{r}

```

### 6.9 Where to Go Next


## Chapter 7: Draw Maps

### 7.1 Map U.S. State-Level Data
```{r}

```

### 7.2 America's Ur-chloropeths

```{r}

```

### 7.3 Statebins

```{r}

```

### 7.4 Small-Multiple Maps

```{r}

```

### 7.5 Is Your Data really Spatial?

```{r}

```

### 7.6 Where to Go Next




## Chapter 8: Refine your Plots

### 8.1 Use Color to Your Advantage

```{r}

```

### 8.2 Layer Color and Text Together

```{r}

```


### 8.3 Change the Appearance of Plots with Themes

```{r}

```


### 8.4 Use Theme Elements ina Substantive Way

```{r}

```

### 8.5 Case Studies

```{r}

```

### 8.6 Where to Go Next

```{r}

```


## Appendix  
  
### A Little More about R
#### How to Read an R help Page  
```{r}
?mean
```  
The help page begins with the name of the function and the library it's in.  

We need to know what a function *requires*, what it *does*, and what it *returns*.  
  
  * What it requires is shown in the *Usage* and *Arguments* sections of the help page.  
  ** The *Usage* section will show default values for arguments (f there are any).  If a named argument has no defualt, you'll have to assign a value.

The *Value* section shows what the function will return.  

Well-documented packages will often have vignettes and demos included.  

### The Basics of accessing and selecting things  
  
  * To access a particular element from a vector, use square brackets:  
  
```{r}
my_numbers

my_numbers[4]

my_numbers[6]
```
  
  * To access a sequence of elements, we can use a colon:  
```{r}
my_numbers[2:4]
```
  
  * To select non-adjacent elements, , use the 'c()' function:
```{r}
my_numbers[c(1,3)]
```
  
We can't simply write 'my_numbers[1,3]', because this is interpreted as row and column from a matrix, data frame, or tibble.  If we create a two-dimensional data set and join together in a tibble:
```{r}
my_tb <- tibble(mine = c(1,4,5, 8:11), yours = c(3,20,16,34:31))

class(my_tb)

my_tb
```
  
  * Now, we can see an example of how '[3,1]' is interpreted as row 3, column 1:  
```{r}
my_tb[3,1] 

my_tb[3,2]
```
  
  * The columns in in our tibble also have names, and we can use these to reference elements:
```{r}
my_tb[3, "mine"]

my_tb[3, "yours"]
```
  
  * If we want all elements from a particular column, we can omit the column reference:
```{r}
my_tb[,"yours"]
```
  
  * Or retrieve the entire row by omitting the column reference:  
```{r}
my_tb[4, ]
```
  
  * A better way to access data from a particular column is via the $ operator:
```{r}
my_tb$mine
```
  
  * We can also extract nested objects this way:
```{r}
?lm

out <- lm(mine ~ yours, data = my_tb)

out

out$coefficients
```
### Common Problems Reading in Data
### Managing Projects and Files
### Some Features of This Book
